/**
 * Admin Routes - Database Inspection & Cleanup
 * For testing and debugging - view and delete connection requests, invitations, connections
 */

import { Hono } from "npm:hono";
import { createClient } from 'jsr:@supabase/supabase-js';
import * as kv from "./kv_store.ts";
import { Keys } from './database.ts';

const admin = new Hono();

// Create Supabase admin client
const supabase = createClient(
  Deno.env.get('SUPABASE_URL') ?? '',
  Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
);

// Define prefixes for database queries
const Prefixes = {
  USER_PROFILE: 'user:',
  CONNECTION: 'connection:',
  CONNECTION_REQUEST: 'connection_request:',
  INVITATION: 'invitation:',
  MEMORY: 'memory:',
};

/**
 * GET /make-server-deded1eb/admin/connection-requests
 * Get all connection requests
 */
admin.get("/make-server-deded1eb/admin/connection-requests", async (c) => {
  try {
    console.log('[ADMIN] Fetching all connection requests');

    // Get all connection request keys
    const requestKeys = await kv.getByPrefix(Prefixes.CONNECTION_REQUEST);
    
    const requests = await Promise.all(
      requestKeys.map(async (key) => {
        const request = await kv.get(key);
        if (!request) return null;

        // Get sender and receiver profiles
        const [senderProfile, receiverProfile] = await Promise.all([
          kv.get(`${Prefixes.USER_PROFILE}${request.sender_id}`),
          kv.get(`${Prefixes.USER_PROFILE}${request.receiver_id}`)
        ]);

        return {
          id: key,
          ...request,
          sender_name: senderProfile?.name || 'Unknown',
          sender_email: senderProfile?.email || '',
          receiver_name: receiverProfile?.name || 'Unknown',
          receiver_email: receiverProfile?.email || ''
        };
      })
    );

    const validRequests = requests.filter(r => r !== null);

    console.log(`[ADMIN] Found ${validRequests.length} connection requests`);

    return c.json({
      success: true,
      requests: validRequests,
      count: validRequests.length
    });
  } catch (error) {
    console.error('[ADMIN] Error fetching connection requests:', error);
    return c.json({
      success: false,
      error: error instanceof Error ? error.message : 'Failed to fetch connection requests'
    }, 500);
  }
});

/**
 * DELETE /make-server-deded1eb/admin/connection-requests/:id
 * Delete a connection request by ID
 */
admin.delete("/make-server-deded1eb/admin/connection-requests/:id", async (c) => {
  try {
    const requestId = c.req.param('id');
    console.log('[ADMIN] Deleting connection request:', requestId);

    // Check if exists
    const request = await kv.get(requestId);
    if (!request) {
      return c.json({
        success: false,
        error: 'Connection request not found'
      }, 404);
    }

    // Delete the request
    await kv.del(requestId);

    console.log('[ADMIN] Connection request deleted:', requestId);

    return c.json({
      success: true,
      message: 'Connection request deleted successfully'
    });
  } catch (error) {
    console.error('[ADMIN] Error deleting connection request:', error);
    return c.json({
      success: false,
      error: error instanceof Error ? error.message : 'Failed to delete connection request'
    }, 500);
  }
});

/**
 * GET /make-server-deded1eb/admin/invitations
 * Get all invitations
 */
admin.get("/make-server-deded1eb/admin/invitations", async (c) => {
  try {
    console.log('[ADMIN] Fetching all invitations');

    // Get all invitation keys
    const invitationKeys = await kv.getByPrefix(Prefixes.INVITATION);
    
    const invitations = await Promise.all(
      invitationKeys.map(async (key) => {
        const invitation = await kv.get(key);
        if (!invitation) return null;

        // Get sender profile
        const senderProfile = await kv.get(`${Prefixes.USER_PROFILE}${invitation.keeper_id}`);

        return {
          id: key,
          ...invitation,
          sender_name: senderProfile?.name || 'Unknown',
          sender_email: senderProfile?.email || ''
        };
      })
    );

    const validInvitations = invitations.filter(i => i !== null);

    console.log(`[ADMIN] Found ${validInvitations.length} invitations`);

    return c.json({
      success: true,
      invitations: validInvitations,
      count: validInvitations.length
    });
  } catch (error) {
    console.error('[ADMIN] Error fetching invitations:', error);
    return c.json({
      success: false,
      error: error instanceof Error ? error.message : 'Failed to fetch invitations'
    }, 500);
  }
});

/**
 * DELETE /make-server-deded1eb/admin/invitations/:code
 * Delete an invitation by code
 */
admin.delete("/make-server-deded1eb/admin/invitations/:code", async (c) => {
  try {
    const code = c.req.param('code');
    const invitationKey = `${Prefixes.INVITATION}${code}`;
    console.log('[ADMIN] Deleting invitation:', invitationKey);

    // Check if exists
    const invitation = await kv.get(invitationKey);
    if (!invitation) {
      return c.json({
        success: false,
        error: 'Invitation not found'
      }, 404);
    }

    // Delete the invitation
    await kv.del(invitationKey);

    console.log('[ADMIN] Invitation deleted:', invitationKey);

    return c.json({
      success: true,
      message: 'Invitation deleted successfully'
    });
  } catch (error) {
    console.error('[ADMIN] Error deleting invitation:', error);
    return c.json({
      success: false,
      error: error instanceof Error ? error.message : 'Failed to delete invitation'
    }, 500);
  }
});

/**
 * GET /make-server-deded1eb/admin/connections
 * Get all connections
 */
admin.get("/make-server-deded1eb/admin/connections", async (c) => {
  try {
    console.log('[ADMIN] Fetching all connections');

    // Get all connection keys
    const connectionKeys = await kv.getByPrefix(Prefixes.CONNECTION);
    
    const connections = await Promise.all(
      connectionKeys.map(async (key) => {
        const connection = await kv.get(key);
        if (!connection) return null;

        // Get keeper and teller profiles
        const [keeperProfile, tellerProfile] = await Promise.all([
          kv.get(`${Prefixes.USER_PROFILE}${connection.keeper_id}`),
          kv.get(`${Prefixes.USER_PROFILE}${connection.teller_id}`)
        ]);

        // Determine if same-role based on keeper/teller type
        const isSameRole = keeperProfile?.type === tellerProfile?.type;

        return {
          id: key,
          ...connection,
          keeper_name: keeperProfile?.name || 'Unknown',
          keeper_email: keeperProfile?.email || '',
          teller_name: tellerProfile?.name || 'Unknown',
          teller_email: tellerProfile?.email || '',
          is_same_role: isSameRole
        };
      })
    );

    const validConnections = connections.filter(c => c !== null);

    console.log(`[ADMIN] Found ${validConnections.length} connections`);

    return c.json({
      success: true,
      connections: validConnections,
      count: validConnections.length
    });
  } catch (error) {
    console.error('[ADMIN] Error fetching connections:', error);
    return c.json({
      success: false,
      error: error instanceof Error ? error.message : 'Failed to fetch connections'
    }, 500);
  }
});

/**
 * POST /make-server-deded1eb/admin/search-connections
 * Search for connections by user email
 */
admin.post("/make-server-deded1eb/admin/search-connections", async (c) => {
  try {
    const { email } = await c.req.json();
    
    if (!email) {
      return c.json({
        success: false,
        error: 'Email is required'
      }, 400);
    }

    console.log('[ADMIN] Searching connections for email:', email);

    // First find the user by email
    const userKeys = await kv.getByPrefix(Prefixes.USER_PROFILE);
    let targetUserId = null;
    
    for (const key of userKeys) {
      const profile = await kv.get(key);
      if (profile && profile.email && profile.email.toLowerCase() === email.toLowerCase()) {
        targetUserId = profile.id;
        break;
      }
    }

    if (!targetUserId) {
      return c.json({
        success: false,
        error: 'User not found with that email'
      }, 404);
    }

    // Get all connections where this user is involved
    const connectionKeys = await kv.getByPrefix(Prefixes.CONNECTION);
    const userConnections = [];

    for (const key of connectionKeys) {
      const connection = await kv.get(key);
      if (!connection) continue;

      // Check if this user is either the keeper or teller
      if (connection.keeper_id === targetUserId || connection.teller_id === targetUserId) {
        // Get profiles for both users
        const [keeperProfile, tellerProfile] = await Promise.all([
          kv.get(`${Prefixes.USER_PROFILE}${connection.keeper_id}`),
          kv.get(`${Prefixes.USER_PROFILE}${connection.teller_id}`)
        ]);

        // Count memories for this connection
        const memoryKeys = await kv.getByPrefix(`${Prefixes.MEMORY}${connection.id}:`);
        
        userConnections.push({
          connectionId: connection.id,
          keeperId: connection.keeper_id,
          keeperName: keeperProfile?.name || 'Unknown',
          keeperEmail: keeperProfile?.email || '',
          keeperType: keeperProfile?.type || 'unknown',
          tellerId: connection.teller_id,
          tellerName: tellerProfile?.name || 'Unknown',
          tellerEmail: tellerProfile?.email || '',
          tellerType: tellerProfile?.type || 'unknown',
          memoryCount: memoryKeys.length,
          createdAt: connection.created_at || new Date().toISOString(),
          isSameRole: keeperProfile?.type === tellerProfile?.type
        });
      }
    }

    console.log(`[ADMIN] Found ${userConnections.length} connections for user ${targetUserId}`);

    return c.json({
      success: true,
      userId: targetUserId,
      email: email,
      connections: userConnections,
      count: userConnections.length
    });
  } catch (error) {
    console.error('[ADMIN] Error searching connections:', error);
    return c.json({
      success: false,
      error: error instanceof Error ? error.message : 'Failed to search connections'
    }, 500);
  }
});

/**
 * DELETE /make-server-deded1eb/admin/connections/:id
 * Delete a connection by ID
 */
admin.delete("/make-server-deded1eb/admin/connections/:id", async (c) => {
  try {
    const connectionId = c.req.param('id');
    console.log('[ADMIN] Deleting connection:', connectionId);

    // Check if exists
    const connection = await kv.get(connectionId);
    if (!connection) {
      return c.json({
        success: false,
        error: 'Connection not found'
      }, 404);
    }

    // Delete the connection
    await kv.del(connectionId);

    // Also delete all memories for this connection
    const memoryKeys = await kv.getByPrefix(`${Prefixes.MEMORY}${connection.id}:`);
    if (memoryKeys.length > 0) {
      console.log(`[ADMIN] Deleting ${memoryKeys.length} memories for connection ${connection.id}`);
      await kv.mdel(memoryKeys);
    }

    console.log('[ADMIN] Connection deleted:', connectionId);

    return c.json({
      success: true,
      message: 'Connection and associated memories deleted successfully',
      memoriesDeleted: memoryKeys.length
    });
  } catch (error) {
    console.error('[ADMIN] Error deleting connection:', error);
    return c.json({
      success: false,
      error: error instanceof Error ? error.message : 'Failed to delete connection'
    }, 500);
  }
});

/**
 * GET /make-server-deded1eb/admin/health
 * Health check for admin
 */
admin.get("/make-server-deded1eb/admin/health", async (c) => {
  return c.json({
    success: true,
    message: 'Admin API is running',
    timestamp: new Date().toISOString()
  });
});

/**
 * POST /make-server-deded1eb/admin/check-profile
 * Check a user profile by email
 */
admin.post("/make-server-deded1eb/admin/check-profile", async (c) => {
  try {
    const { email } = await c.req.json();
    
    if (!email) {
      return c.json({
        success: false,
        error: 'Email is required'
      }, 400);
    }

    console.log('[ADMIN] Checking profile for email:', email);

    // Find user by email
    const userKeys = await kv.getByPrefix(Prefixes.USER_PROFILE);
    let userProfile = null;
    
    for (const key of userKeys) {
      const profile = await kv.get(key);
      if (profile && profile.email && profile.email.toLowerCase() === email.toLowerCase()) {
        userProfile = profile;
        break;
      }
    }

    if (!userProfile) {
      return c.json({
        success: false,
        error: 'User not found with that email'
      }, 404);
    }

    return c.json({
      success: true,
      profile: {
        id: userProfile.id,
        name: userProfile.name,
        email: userProfile.email,
        type: userProfile.type,
        relationship: userProfile.relationship,
        bio: userProfile.bio,
        phoneNumber: userProfile.phone_number,
        createdAt: userProfile.created_at || new Date().toISOString()
      }
    });
  } catch (error) {
    console.error('[ADMIN] Error checking profile:', error);
    return c.json({
      success: false,
      error: error instanceof Error ? error.message : 'Failed to check profile'
    }, 500);
  }
});

/**
 * GET /make-server-deded1eb/admin/check-invitations
 * Check all invitations
 */
admin.get("/make-server-deded1eb/admin/check-invitations", async (c) => {
  try {
    console.log('[ADMIN] Checking all invitations');

    const invitationKeys = await kv.getByPrefix(Prefixes.INVITATION);
    const invitations = [];

    for (const key of invitationKeys) {
      const invitation = await kv.get(key);
      if (!invitation) continue;

      const keeperProfile = await kv.get(`${Prefixes.USER_PROFILE}${invitation.keeper_id}`);

      invitations.push({
        code: invitation.code,
        keeperId: invitation.keeper_id,
        keeperName: keeperProfile?.name || 'Unknown',
        tellerName: invitation.teller_name || '',
        status: invitation.status,
        createdAt: invitation.created_at || new Date().toISOString()
      });
    }

    return c.json({
      success: true,
      invitations: invitations
    });
  } catch (error) {
    console.error('[ADMIN] Error checking invitations:', error);
    return c.json({
      success: false,
      error: error instanceof Error ? error.message : 'Failed to check invitations'
    }, 500);
  }
});

/**
 * GET /make-server-deded1eb/admin/check-users
 * Check all users
 */
admin.get("/make-server-deded1eb/admin/check-users", async (c) => {
  try {
    console.log('[ADMIN] Checking all users');

    const userKeys = await kv.getByPrefix(Prefixes.USER_PROFILE);
    const users = [];

    for (const key of userKeys) {
      const profile = await kv.get(key);
      if (!profile) continue;

      users.push({
        id: profile.id,
        name: profile.name,
        email: profile.email,
        type: profile.type,
        createdAt: profile.created_at || new Date().toISOString()
      });
    }

    return c.json({
      success: true,
      users: users
    });
  } catch (error) {
    console.error('[ADMIN] Error checking users:', error);
    return c.json({
      success: false,
      error: error instanceof Error ? error.message : 'Failed to check users'
    }, 500);
  }
});

/**
 * GET /make-server-deded1eb/admin/check-connections
 * Check all connections
 */
admin.get("/make-server-deded1eb/admin/check-connections", async (c) => {
  try {
    console.log('[ADMIN] Checking all connections');

    const connectionKeys = await kv.getByPrefix(Prefixes.CONNECTION);
    const connections = [];

    for (const key of connectionKeys) {
      const connection = await kv.get(key);
      if (!connection) continue;

      const [keeperProfile, tellerProfile] = await Promise.all([
        kv.get(`${Prefixes.USER_PROFILE}${connection.keeper_id}`),
        kv.get(`${Prefixes.USER_PROFILE}${connection.teller_id}`)
      ]);

      connections.push({
        connectionId: connection.id,
        keeperName: keeperProfile?.name || 'Unknown',
        keeperType: keeperProfile?.type || 'unknown',
        tellerName: tellerProfile?.name || 'Unknown',
        tellerType: tellerProfile?.type || 'unknown',
        createdAt: connection.created_at || new Date().toISOString()
      });
    }

    return c.json({
      success: true,
      connections: connections
    });
  } catch (error) {
    console.error('[ADMIN] Error checking connections:', error);
    return c.json({
      success: false,
      error: error instanceof Error ? error.message : 'Failed to check connections'
    }, 500);
  }
});

/**
 * POST /make-server-deded1eb/admin/cleanup-user
 * Delete a user and all associated data
 */
admin.post("/make-server-deded1eb/admin/cleanup-user", async (c) => {
  try {
    const { email } = await c.req.json();
    
    if (!email) {
      return c.json({
        success: false,
        error: 'Email is required'
      }, 400);
    }

    console.log('[ADMIN] Cleaning up user:', email);

    // Find user by email
    const userKeys = await kv.getByPrefix(Prefixes.USER_PROFILE);
    let userId = null;
    let userKey = null;
    
    for (const key of userKeys) {
      const profile = await kv.get(key);
      if (profile && profile.email && profile.email.toLowerCase() === email.toLowerCase()) {
        userId = profile.id;
        userKey = key;
        break;
      }
    }

    if (!userId) {
      return c.json({
        success: false,
        error: 'User not found with that email'
      }, 404);
    }

    // Delete connections
    const connectionKeys = await kv.getByPrefix(Prefixes.CONNECTION);
    let deletedConnections = 0;
    let deletedMemories = 0;

    for (const key of connectionKeys) {
      const connection = await kv.get(key);
      if (connection && (connection.keeper_id === userId || connection.teller_id === userId)) {
        // Delete memories for this connection
        const memoryKeys = await kv.getByPrefix(`${Prefixes.MEMORY}${connection.id}:`);
        if (memoryKeys.length > 0) {
          await kv.mdel(memoryKeys);
          deletedMemories += memoryKeys.length;
        }
        
        // Delete connection
        await kv.del(key);
        deletedConnections++;
      }
    }

    // Delete invitations
    const invitationKeys = await kv.getByPrefix(Prefixes.INVITATION);
    let deletedInvitations = 0;

    for (const key of invitationKeys) {
      const invitation = await kv.get(key);
      if (invitation && invitation.keeper_id === userId) {
        await kv.del(key);
        deletedInvitations++;
      }
    }

    // Delete user profile
    await kv.del(userKey);

    console.log(`[ADMIN] User cleanup complete: ${deletedConnections} connections, ${deletedMemories} memories, ${deletedInvitations} invitations deleted`);

    return c.json({
      success: true,
      userId: userId,
      deletedConnections: deletedConnections,
      deletedMemories: deletedMemories,
      deletedInvitations: deletedInvitations
    });
  } catch (error) {
    console.error('[ADMIN] Error cleaning up user:', error);
    return c.json({
      success: false,
      error: error instanceof Error ? error.message : 'Failed to cleanup user'
    }, 500);
  }
});

/**
 * POST /make-server-deded1eb/admin/cleanup-orphans
 * Delete orphaned invitations and connection requests
 */
admin.post("/make-server-deded1eb/admin/cleanup-orphans", async (c) => {
  try {
    console.log('[ADMIN] Cleaning up orphaned data');

    // Get all user IDs
    const userKeys = await kv.getByPrefix(Prefixes.USER_PROFILE);
    const validUserIds = new Set();
    
    for (const key of userKeys) {
      const profile = await kv.get(key);
      if (profile && profile.id) {
        validUserIds.add(profile.id);
      }
    }

    let deletedCount = 0;

    // Check invitations
    const invitationKeys = await kv.getByPrefix(Prefixes.INVITATION);
    for (const key of invitationKeys) {
      const invitation = await kv.get(key);
      if (invitation && !validUserIds.has(invitation.keeper_id)) {
        await kv.del(key);
        deletedCount++;
      }
    }

    // Check connection requests
    const requestKeys = await kv.getByPrefix(Prefixes.CONNECTION_REQUEST);
    for (const key of requestKeys) {
      const request = await kv.get(key);
      if (request && (!validUserIds.has(request.sender_id) || !validUserIds.has(request.receiver_id))) {
        await kv.del(key);
        deletedCount++;
      }
    }

    console.log(`[ADMIN] Cleanup complete: ${deletedCount} orphaned items deleted`);

    return c.json({
      success: true,
      deletedCount: deletedCount
    });
  } catch (error) {
    console.error('[ADMIN] Error cleaning up orphans:', error);
    return c.json({
      success: false,
      error: error instanceof Error ? error.message : 'Failed to cleanup orphans'
    }, 500);
  }
});

export default admin;
